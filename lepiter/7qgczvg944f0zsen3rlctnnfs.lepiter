{
	"__schema" : "4.1",
	"__type" : "page",
	"children" : {
		"__type" : "snippets",
		"items" : [
			{
				"__type" : "textSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-02-18T10:06:24.94+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-02-18T10:10:50.811+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "4Js5scjqDQCSbT7RCZ6mgg=="
				},
				"paragraphStyle" : {
					"__type" : "textStyle"
				},
				"string" : "The following is an incomplete, underdocumented Smalltalk parser written in an unpublished language using parser combinators as a demo ([try it](https://software.zeniko.ch/private/zs.html/#code=8P/////////////////////////////dIyBodHRwczovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL0NhdGVnb3J5OlNtYWxsdGFsawoKc21hbGx0YWxrX3BhcnNlciA9IGZuKCkgewoJIyBwYXJzZWMgaXMgYSBwYXJzZXIgY29tYmluYXRvciBsaWJyYXJ5IHByb3ZpZGluZyAKCSMgICBzKCkgICAgICAgIG1hdGNoIGEgc3RyaW5nCgkjICAgcngoKSAgICAgICBtYXRjaCBhbiBleHRlbmRlZCByZWdleCAoc3ludGF4IHNpbWlsYXIgdG8gRUNNQVNjcmlwdCkKCSMgICBuZWcoKSAgICAgIGZhaWwgdG8gbWF0Y2gKCSMgICBvcHQoKSAgICAgIG1hdGNoIHplcm8gb3Igb25lCgkjICAgYW55KCkgICAgICBtYXRjaCB6ZXJvLCBvbmUgb3IgbW9yZQoJIyAgIHNlcSgpICAgICAgbWF0Y2ggYWxsIHBhcnRzIGluIHNlcXVlbmNlCgkjICAgYWx0KCkgICAgICBtYXRjaCBvbmUgb2YgaXRzIGFsdGVybmF0ZSBvcHRpb25zIChsZWZ0IHRvIHJpZ2h0KQoJIyAgIHNraXAoKSAgICAgZXhjbHVkZSBmcm9tIHBhcnNlIHRyZWUKCSMgICBiZXR3ZWVuKCkgIG1hdGNoIG11c3QgbGllIGJldHdlZW4gZ2l2ZW4gcGFydChzKQoJIyAgIGFueTEoKSAgICAgbWF0Y2ggb25lIG9yIG1vcmUKCSMgICBkZWZlcigpICAgIHJlcXVpcmVkIGZvciByZWN1cnNpdmUgZGVmaW5pdGlvbnM6IHByZXBhcmVzIGEgcmVmZXJlbmNlIChpbiBhIGJveCA9IHNpbmdsZS1pdGVtIGxpc3QpIGZvciBhIGRlZmluaXRpb24gd2hpY2ggd2lsbCBvbmx5IGxhdGVyIGJlY29tZSBhdmFpbGFibGUKCSMgICBtYXAoKSAgICAgIHRyYW5zZm9ybSB0aGUgbWF0Y2gKCSMgICBlbmQoKSAgICAgIG1hdGNoIHRoZSBlbmQKCWltcG9ydCBwYXJzZWMgZm9yICoKCQoJc3BhY2VzID0gcngoYFxzKmApLnNraXAoKQoJCglhbnlDaGFyID0gcngoYCg/cykuYCkKCWRpZ2l0ID0gcngoYFxkYCkKCWxldHRlciA9IHJ4KGBbYS16QS1aX11gKQoJYmluT3BzID0gcngoYFsrXC0qL358LDw+PSZAP1xcJV17MSwyfWApCgkKCXJhZGl4ID0gcngoYFxkfFsxLTJdXGR8M1swLTZdYCkKCXNpZ24gPSBzKCItIikub3B0KCkKCWludGVnZXJDb25zdCA9IHJhZGl4LnNlcShzKCJyIikpLm9wdCgpLnNlcShzaWduLCBkaWdpdC5hbnkxKCkpLm1hcChmbigqYSkgeyB7IGludGVnZXI6IGEuam9pbigiIikgfSB9KQoJZXhwID0gcygiZSIpLnNlcShzaWduLCBkaWdpdC5hbnkxKCkpCglmbG9hdENvbnN0ID0gc2lnbi5zZXEoZGlnaXQuYW55MSgpLCBzKCIuIikuc2VxKGRpZ2l0LmFueTEoKSwgZXhwLm9wdCgpKS5hbHQoZXhwKSkubWFwKGZuKCphKSB7IHsgZmxvYXQ6IGEuam9pbigiIikgfSB9KQoJbnVtYmVyID0gZmxvYXRDb25zdC5hbHQoaW50ZWdlckNvbnN0KQoJCgl2YXJpYWJsZSA9IGxldHRlci5zZXEobGV0dGVyLmFsdChkaWdpdCkuYW55KCksIHMoIjoiKS5uZWcoKSkuYmV0d2VlbihzcGFjZXMpLm1hcChmbigqYSkgeyBhLmpvaW4oIiIpIH0pCglrZXl3b3JkID0gbGV0dGVyLnNlcShsZXR0ZXIuYWx0KGRpZ2l0KS5hbnkoKSwgcygiOiIpKS5tYXAoZm4oKmEpIHsgYS5qb2luKCIiKSB9KQoJCglzdHJpbmdDb25zdCA9IHMoIicnIikuYWx0KHMoIiciKS5uZWcoKS5zZXEoYW55Q2hhcikpLmFueSgpLmJldHdlZW4ocygiJyIpLnNraXAoKSkubWFwKGZuKCphKSB7IHsgc3RyaW5nOiBhLmpvaW4oIiIpLnJlcGxhY2UoIicnIiwgIiciKSB9IH0pCgljaGFyYWN0ZXJDb25zdCA9IHMoIiQiKS5zZXEoYW55Q2hhcikubWFwKGZuKCphKSB7IHsgY2hhcmFjdGVyOiBhLjEgfSB9KQoJCglzZWxlY3RvciA9IGtleXdvcmQuYWx0KGJpbk9wcywgdmFyaWFibGUpLmJldHdlZW4oc3BhY2VzKQoJc3ltYm9sQ29uc3QgPSBzKCIjIikuc2tpcCgpLnNlcShzdHJpbmdDb25zdC5hbHQoc2VsZWN0b3IpKS5tYXAoYSAtPiB7IGNvbnN0OiBhIH0pCglhcnJheUxpc3RCb3ggPSBbbm9uZV0KCWFycmF5TGlzdCA9IGRlZmVyKGFycmF5TGlzdEJveCkKCWFycmF5Q29uc3QgPSBzKCIjIikuc2tpcCgpLnNlcShhcnJheUxpc3QpCgkKCWxpdGVyYWwgPSBudW1iZXIuYWx0KHN0cmluZ0NvbnN0LCBjaGFyYWN0ZXJDb25zdCwgc3ltYm9sQ29uc3QsIGFycmF5Q29uc3QpCgkKCWFycmF5TGlzdEJveC4wID0gbGl0ZXJhbC5hbHQoYXJyYXlMaXN0KS5iZXR3ZWVuKHNwYWNlcykuYW55KCkuYmV0d2VlbihzKCIoIiksIHMoIikiKSkubWFwKGZuKCphKSB7IHsgYXJyYXk6IGEgfSB9KQoJCglleHByZXNzaW9uQm94ID0gW25vbmVdCglleHByZXNzaW9uID0gZGVmZXIoZXhwcmVzc2lvbkJveCkKCWFzc2lnbm1lbnQgPSB2YXJpYWJsZS5zZXEocygiOj0iKS5za2lwKCkpLmFueTEoKS5zZXEoZXhwcmVzc2lvbikubWFwKGZuKCphKSB7IHsgYXNzaWduOiBbYVs6LTFdLCBhWy0xXV0gfSB9KQoJCglibG9ja0JveCA9IFtub25lXQoJYmxvY2sgPSBkZWZlcihibG9ja0JveCkKCXByaW1hcnkgPSB2YXJpYWJsZS5hbHQobGl0ZXJhbCwgYmxvY2ssIGV4cHJlc3Npb24uYmV0d2VlbihzKCIoIiksIHMoIikiKSkpLmJldHdlZW4oc3BhY2VzKQoJCgl1bmFyeVNlbEV4cHIgPSB2YXJpYWJsZQoJdW5hcnlFeHByZXNzaW9uID0gcHJpbWFyeS5zZXEodW5hcnlTZWxFeHByLmFueSgpKS5tYXAoZm4gbmVzdF91bmFyeSgqYSkgeyBpZiBhLnNpemUoKSA9PSAxIHsgYS4wIH0gZWxzZSB7IG5lc3RfdW5hcnkoeyB1bmFyeTogYVs6Ml0gfSwgKmFbMjpdKSB9IH0pCgliaW5hcnlTZWxFeHByID0gYmluT3BzLnNlcSh1bmFyeUV4cHJlc3Npb24pCgliaW5hcnlFeHByZXNzaW9uID0gdW5hcnlFeHByZXNzaW9uLnNlcShiaW5hcnlTZWxFeHByLmFueSgpKS5tYXAoZm4gbmVzdF9iaW5hcnkoKmEpIHsgaWYgYS5zaXplKCkgPT0gMSB7IGEuMCB9IGVsc2UgeyBuZXN0X2JpbmFyeSh7IGJpbmFyeTogYVs6M10gfSwgKmFbMzpdKSB9IH0pCglrZXl3b3JkU2VsRXhwciA9IGtleXdvcmQuc2VxKGJpbmFyeUV4cHJlc3Npb24pCglrZXl3b3JkRXhwcmVzc2lvbiA9IGJpbmFyeUV4cHJlc3Npb24uc2VxKGtleXdvcmRTZWxFeHByLmFueSgpKS5tYXAoZm4oKmEpIHsgaWYgYS5zaXplKCkgPT0gMSB7IGEuMCB9IGVsc2UgeyBhIH0gfSkKCW1lc3NhZ2VTZW5kID0ga2V5d29yZEV4cHJlc3Npb24uc2VxKHMoIjsiKS5iZXR3ZWVuKHNwYWNlcykuc2VxKGtleXdvcmRTZWxFeHByLmFsdChiaW5hcnlTZWxFeHByLCB1bmFyeVNlbEV4cHIpLmFueSgpKS5hbnkoKSkKCQoJZXhwcmVzc2lvbkJveC4wID0gYXNzaWdubWVudC5hbHQobWVzc2FnZVNlbmQpCgkKCWxvY2FsVmFyRGVjbCA9IHZhcmlhYmxlLmFueSgpLmJldHdlZW4ocygifCIpKS5tYXAoZm4oKmEpIHsgeyB2YXJpYWJsZXM6IGEgfSB9KQoJCglzdGF0ZW1lbnRzID0gbG9jYWxWYXJEZWNsLm9wdCgpLnNlcShleHByZXNzaW9uLnNlcShzKCIuIikuc2tpcCgpKS5hbnkoKSwgcygiXiIpLmJldHdlZW4oc3BhY2VzKS5vcHQoKS5zZXEoZXhwcmVzc2lvbikuYWx0KHMoIi4iKS5za2lwKCkpLm9wdCgpKQoJYmxvY2tCb3guMCA9IHMoIjoiKS5zZXEodmFyaWFibGUpLmFueSgpLnNlcShzKCJ8IikpLm9wdCgpLnNlcShzdGF0ZW1lbnRzKS5iZXR3ZWVuKHNwYWNlcykuYmV0d2VlbihzKCJbIiksIHMoIl0iKSkubWFwKGZuKCphKSB7IHsgYmxvY2s6IGEgfSB9KQoJCgltZXRob2RTcGVjID0ga2V5d29yZC5zZXEodmFyaWFibGUpLmFueTEoKS5hbHQoYmluT3BzLnNlcSh2YXJpYWJsZSksIHZhcmlhYmxlKQoJcHJhZ21hID0ga2V5d29yZEV4cHJlc3Npb24uYmV0d2VlbihzKCI8IiksIHMoIj4iKSkubWFwKGZuKCphKSB7IHsgcHJhZ21hOiBhIH0gfSkKCW1ldGhvZCA9IG1ldGhvZFNwZWMuc2VxKHByYWdtYS5vcHQoKSwgc3RhdGVtZW50cykuYmV0d2VlbihzcGFjZXMpCgkKCW1ldGhvZC5lbmQoKQp9KCkKCnRlc3RfYmxvY2tzID0gWwoJIjEyMzQiLAoJIjEyMzQuIiwKCSIxMjM0LjU2IiwKCSIgMTIzNCAiLAoJIidzdHJpbmcnIiwKCSIxMjM0IHByaW50IiwKCSIxMjM0IHNpemUgcHJpbnQiLAoJIjEgKyAyIC0gMyAvIDQiLAoJIjEgKyAyIC0gKDMgLyA0KSIsCgkiMTIzNCBwcmludC4gMSArIDIgcHJpbnQuIiwKCSIxMjM0IHByaW50LiAxICsgKDIgLSAzIC8gNCkiLAoJIl5yZXR1cm5lZCIsICJeIHJldHVybmVkIiwKCSIyIHJhaXNlZFRvOiAzIiwKCSJUcmFuc2NyaXB0IHNob3c6ICdIZWxsbywgV29ybGQhJy4iLAoJIjEyMzQgYmV0d2VlbjogMTAgYW5kOiAxMiIsCgkiYSA6PSBiIDo9IDEgKyAyIiwKCSIoKDEgKyAyKSkiLAoJIiBteXZhciBhdDogKDIgKyAzKSBwdXQ6ICg0KSIsCgkiIChteXZhciBhdDogKDIgKyAzKSBwdXQ6ICg0KSkiLAoJIjUgcmFpc2VkVG86IDcgLSAyIHNxdWFyZWQiLAoJIiBeIDIgLyA0IHJvdW5kdXAgIiwKCSJteWJvb2wgaWZUcnVlOiBbIF4gMiAvIDQgcm91bmR1cCBdIiwKCSJkaXNwbGF5IGRyYXdGcm9tWDogMSBmcm9tWTogMSB0b1g6IDUwIHRvWTogMTAwLiIsCgkidHJ1ZSAmIGZhbHNlIG5vdCAmIChuaWwgaXNOaWwpIGlmRmFsc2U6IFtzZWxmIGhhbHRdLiIsCgkifCB5IHwgeSA6PSBzZWxmIHNpemUgKyBzdXBlciBzaXplLiIsCgkiIygxICgyIDMpKSIsCgkiIygkYSAjYSAnYScgMSAxLjApIiwKCSIxIHNxdWFyZWQ7IHJvb3RlZCIsCgkiVHJhbnNjcmlwdCBzaG93OiAxOyBzaG93OiAyIiwKCSIxIGRvOiBbIDplYWNoIHwgMSBdLiIsCgkidGhpbmcgZG86IDEgYW5kOiAyOyBkbzogMyBhbmQ6IDQiLApdCnRlc3RfbWV0aG9kcyA9IFsKCSIiIgoJbmFtZSBeIDEKCSIiIiwKCSIiIgoJbmFtZQoJCTEgKyAyLgoJIiIiLAoJIiIiCglkb1NvbWV0aGluZ1dpdGg6IGFyZ3VtZW50T2JqZWN0CgkJc2VsZiBzaXplID4gNCBpZlRydWU6IFteYXJndW1lbnRPYmplY3Qgc2l6ZVJlbGF0aW5nVG86IHNlbGZdLgoJIiIiLAoJIiIiCgltYXg6IGFOdW1iZXIKCQlec2VsZiA8IGFOdW1iZXIgaWZUcnVlOiBbYU51bWJlcl0gaWZGYWxzZTogW3NlbGZdCgkiIiIsCgkiIiIKCWZpYm9uYWNjaQoJCXNlbGYgPiAxIGlmVHJ1ZTogW14gKHNlbGYgLSAxKSBmaWJvbmFjY2kgKyAoc2VsZiAtIDIpIGZpYm9uYWNjaV0uCgkJXiBzZWxmCgkiIiIsCgkiIiIKCWV4YW1wbGVXaXRoTnVtYmVyOiB4CgkJfCB5IHwKCQl0cnVlICYgZmFsc2Ugbm90ICYgKG5pbCBpc05pbCkgaWZGYWxzZTogW3NlbGYgaGFsdF0uCgkJeSA6PSBzZWxmIHNpemUgKyBzdXBlciBzaXplLgoJCSMoJGEgI2EgJ2EnIDEgMS4wKQoJCQlkbzogWyA6ZWFjaCB8CgkJCQlUcmFuc2NyaXB0IHNob3c6IChlYWNoIGNsYXNzIG5hbWUpOwoJCQkJCQkgICBzaG93OiAnICddLgoJCV54IDwgeQoJIiIiLAoJIiIiCgluYW1lCgkJPHByYWdtYT4KCQleIHJldHVybgoJIiIiLAoJIiIiCglndFZpZXdDb250YWN0c09uOiBhVmlldwoJCTxndFZpZXc+CgkJXiBhVmlldyBjb2x1bW5lZExpc3QKCQkJdGl0bGU6ICdDb250YWN0cyB3aXRoIGRldGFpbHMnIHRyYW5zbGF0ZWQ7CgkJCXByaW9yaXR5OiA1OwoJCQlpdGVtczogWyBzZWxmIGNvbnRhY3RzIF07CgkJCWNvbHVtbjogJ0F2YXRhcicgCgkJCQlpY29uOiBbIDphQ29udGFjdCB8IGFDb250YWN0IGF2YXRhciBhc0VsZW1lbnQgYXNTY2FsYWJsZUVsZW1lbnQgc2l6ZTogMzIgQCAzMiBdCgkJCQl3aWR0aDogNzU7CgkJCWNvbHVtbjogJ05hbWUnIHRleHQ6IFsgOmFDb250YWN0IHwgYUNvbnRhY3QgZnVsbE5hbWUgXTsKCQkJY29sdW1uOiAnUGhvbmUnIHRleHQ6IFsgOmFDb250YWN0IHwgYUNvbnRhY3QgdGVsZXBob25lIF0KCSIiIiwKXQppbXBvcnQgc3RyaW5nIGZvciBbcHJldHR5XQpmb3IgY29kZSBpbiB0ZXN0X2Jsb2NrcyB7CgkoIl8gIiArIGNvZGUpLnNtYWxsdGFsa19wYXJzZXIoKS5hc3NlcnQoKS5wcmV0dHkoKS5wcmludCgpCn0KZm9yIGNvZGUgaW4gdGVzdF9tZXRob2RzIHsKCWNvZGUuc21hbGx0YWxrX3BhcnNlcigpLmFzc2VydCgpLnByZXR0eSgpLnByaW50KCkKfQo=)):"
			},
			{
				"__type" : "processingSnippet",
				"children" : {
					"__type" : "snippets",
					"items" : [ ]
				},
				"createEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"createTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-29T20:29:38.458+01:00"
					}
				},
				"editEmail" : {
					"__type" : "email",
					"emailString" : "<unknown>"
				},
				"editTime" : {
					"__type" : "time",
					"time" : {
						"__type" : "dateAndTime",
						"dateAndTimeString" : "2025-10-29T20:29:41.699+01:00"
					}
				},
				"uid" : {
					"__type" : "uid",
					"uidString" : "kEnn47L+DQCqtzSRAEJ5hg=="
				},
				"code" : "# https://rosettacode.org/wiki/Category:Smalltalk\r\n\r\nsmalltalk_parser = fn() {\r\n\t# parsec is a parser combinator library providing \r\n\t#   s()        match a string\r\n\t#   rx()       match an extended regex (syntax similar to ECMAScript)\r\n\t#   neg()      fail to match\r\n\t#   opt()      match zero or one\r\n\t#   any()      match zero, one or more\r\n\t#   seq()      match all parts in sequence\r\n\t#   alt()      match one of its alternate options (left to right)\r\n\t#   skip()     exclude from parse tree\r\n\t#   between()  match must lie between given part(s)\r\n\t#   any1()     match one or more\r\n\t#   defer()    required for recursive definitions: prepares a reference (in a box = single-item list) for a definition which will only later become available\r\n\t#   map()      transform the match\r\n\t#   end()      match the end\r\n\timport parsec for *\r\n\t\r\n\tspaces = rx(`\\s*`).skip()\r\n\t\r\n\tanyChar = rx(`(?s).`)\r\n\tdigit = rx(`\\d`)\r\n\tletter = rx(`[a-zA-Z_]`)\r\n\tbinOps = rx(`[+\\-*/~|,<>=&@?\\\\%]{1,2}`)\r\n\t\r\n\tradix = rx(`\\d|[1-2]\\d|3[0-6]`)\r\n\tsign = s(\"-\").opt()\r\n\tintegerConst = radix.seq(s(\"r\")).opt().seq(sign, digit.any1()).map(fn(*a) { { integer: a.join(\"\") } })\r\n\texp = s(\"e\").seq(sign, digit.any1())\r\n\tfloatConst = sign.seq(digit.any1(), s(\".\").seq(digit.any1(), exp.opt()).alt(exp)).map(fn(*a) { { float: a.join(\"\") } })\r\n\tnumber = floatConst.alt(integerConst)\r\n\t\r\n\tvariable = letter.seq(letter.alt(digit).any(), s(\":\").neg()).between(spaces).map(fn(*a) { a.join(\"\") })\r\n\tkeyword = letter.seq(letter.alt(digit).any(), s(\":\")).map(fn(*a) { a.join(\"\") })\r\n\t\r\n\tstringConst = s(\"''\").alt(s(\"'\").neg().seq(anyChar)).any().between(s(\"'\").skip()).map(fn(*a) { { string: a.join(\"\").replace(\"''\", \"'\") } })\r\n\tcharacterConst = s(\"$\").seq(anyChar).map(fn(*a) { { character: a.1 } })\r\n\t\r\n\tselector = keyword.alt(binOps, variable).between(spaces)\r\n\tsymbolConst = s(\"#\").skip().seq(stringConst.alt(selector)).map(a -> { const: a })\r\n\tarrayListBox = [none]\r\n\tarrayList = defer(arrayListBox)\r\n\tarrayConst = s(\"#\").skip().seq(arrayList)\r\n\t\r\n\tliteral = number.alt(stringConst, characterConst, symbolConst, arrayConst)\r\n\t\r\n\tarrayListBox.0 = literal.alt(arrayList).between(spaces).any().between(s(\"(\"), s(\")\")).map(fn(*a) { { array: a } })\r\n\t\r\n\texpressionBox = [none]\r\n\texpression = defer(expressionBox)\r\n\tassignment = variable.seq(s(\":=\").skip()).any1().seq(expression).map(fn(*a) { { assign: [a[:-1], a[-1]] } })\r\n\t\r\n\tblockBox = [none]\r\n\tblock = defer(blockBox)\r\n\tprimary = variable.alt(literal, block, expression.between(s(\"(\"), s(\")\"))).between(spaces)\r\n\t\r\n\tunarySelExpr = variable\r\n\tunaryExpression = primary.seq(unarySelExpr.any()).map(fn nest_unary(*a) { if a.size() == 1 { a.0 } else { nest_unary({ unary: a[:2] }, *a[2:]) } })\r\n\tbinarySelExpr = binOps.seq(unaryExpression)\r\n\tbinaryExpression = unaryExpression.seq(binarySelExpr.any()).map(fn nest_binary(*a) { if a.size() == 1 { a.0 } else { nest_binary({ binary: a[:3] }, *a[3:]) } })\r\n\tkeywordSelExpr = keyword.seq(binaryExpression)\r\n\tkeywordExpression = binaryExpression.seq(keywordSelExpr.any()).map(fn(*a) { if a.size() == 1 { a.0 } else { a } })\r\n\tmessageSend = keywordExpression.seq(s(\";\").between(spaces).seq(keywordSelExpr.alt(binarySelExpr, unarySelExpr).any()).any())\r\n\t\r\n\texpressionBox.0 = assignment.alt(messageSend)\r\n\t\r\n\tlocalVarDecl = variable.any().between(s(\"|\")).map(fn(*a) { { variables: a } })\r\n\t\r\n\tstatements = localVarDecl.opt().seq(expression.seq(s(\".\").skip()).any(), s(\"^\").between(spaces).opt().seq(expression).alt(s(\".\").skip()).opt())\r\n\tblockBox.0 = s(\":\").seq(variable).any().seq(s(\"|\")).opt().seq(statements).between(spaces).between(s(\"[\"), s(\"]\")).map(fn(*a) { { block: a } })\r\n\t\r\n\tmethodSpec = keyword.seq(variable).any1().alt(binOps.seq(variable), variable)\r\n\tpragma = keywordExpression.between(s(\"<\"), s(\">\")).map(fn(*a) { { pragma: a } })\r\n\tmethod = methodSpec.seq(pragma.opt(), statements).between(spaces)\r\n\t\r\n\tmethod.end()\r\n}()\r\n\r\ntest_blocks = [\r\n\t\"1234\",\r\n\t\"1234.\",\r\n\t\"1234.56\",\r\n\t\" 1234 \",\r\n\t\"'string'\",\r\n\t\"1234 print\",\r\n\t\"1234 size print\",\r\n\t\"1 + 2 - 3 / 4\",\r\n\t\"1 + 2 - (3 / 4)\",\r\n\t\"1234 print. 1 + 2 print.\",\r\n\t\"1234 print. 1 + (2 - 3 / 4)\",\r\n\t\"^returned\", \"^ returned\",\r\n\t\"2 raisedTo: 3\",\r\n\t\"Transcript show: 'Hello, World!'.\",\r\n\t\"1234 between: 10 and: 12\",\r\n\t\"a := b := 1 + 2\",\r\n\t\"((1 + 2))\",\r\n\t\" myvar at: (2 + 3) put: (4)\",\r\n\t\" (myvar at: (2 + 3) put: (4))\",\r\n\t\"5 raisedTo: 7 - 2 squared\",\r\n\t\" ^ 2 / 4 roundup \",\r\n\t\"mybool ifTrue: [ ^ 2 / 4 roundup ]\",\r\n\t\"display drawFromX: 1 fromY: 1 toX: 50 toY: 100.\",\r\n\t\"true & false not & (nil isNil) ifFalse: [self halt].\",\r\n\t\"| y | y := self size + super size.\",\r\n\t\"#(1 (2 3))\",\r\n\t\"#($a #a 'a' 1 1.0)\",\r\n\t\"1 squared; rooted\",\r\n\t\"Transcript show: 1; show: 2\",\r\n\t\"1 do: [ :each | 1 ].\",\r\n\t\"thing do: 1 and: 2; do: 3 and: 4\",\r\n]\r\ntest_methods = [\r\n\t\"\"\"\r\n\tname ^ 1\r\n\t\"\"\",\r\n\t\"\"\"\r\n\tname\r\n\t\t1 + 2.\r\n\t\"\"\",\r\n\t\"\"\"\r\n\tdoSomethingWith: argumentObject\r\n\t\tself size > 4 ifTrue: [^argumentObject sizeRelatingTo: self].\r\n\t\"\"\",\r\n\t\"\"\"\r\n\tmax: aNumber\r\n\t\t^self < aNumber ifTrue: [aNumber] ifFalse: [self]\r\n\t\"\"\",\r\n\t\"\"\"\r\n\tfibonacci\r\n\t\tself > 1 ifTrue: [^ (self - 1) fibonacci + (self - 2) fibonacci].\r\n\t\t^ self\r\n\t\"\"\",\r\n\t\"\"\"\r\n\texampleWithNumber: x\r\n\t\t| y |\r\n\t\ttrue & false not & (nil isNil) ifFalse: [self halt].\r\n\t\ty := self size + super size.\r\n\t\t#($a #a 'a' 1 1.0)\r\n\t\t\tdo: [ :each |\r\n\t\t\t\tTranscript show: (each class name);\r\n\t\t\t\t\t\t   show: ' '].\r\n\t\t^x < y\r\n\t\"\"\",\r\n\t\"\"\"\r\n\tname\r\n\t\t<pragma>\r\n\t\t^ return\r\n\t\"\"\",\r\n\t\"\"\"\r\n\tgtViewContactsOn: aView\r\n\t\t<gtView>\r\n\t\t^ aView columnedList\r\n\t\t\ttitle: 'Contacts with details' translated;\r\n\t\t\tpriority: 5;\r\n\t\t\titems: [ self contacts ];\r\n\t\t\tcolumn: 'Avatar' \r\n\t\t\t\ticon: [ :aContact | aContact avatar asElement asScalableElement size: 32 @ 32 ]\r\n\t\t\t\twidth: 75;\r\n\t\t\tcolumn: 'Name' text: [ :aContact | aContact fullName ];\r\n\t\t\tcolumn: 'Phone' text: [ :aContact | aContact telephone ]\r\n\t\"\"\",\r\n]\r\nimport string for [pretty]\r\nfor code in test_blocks {\r\n\t(\"_ \" + code).smalltalk_parser().assert().pretty().print()\r\n}\r\nfor code in test_methods {\r\n\tcode.smalltalk_parser().assert().pretty().print()\r\n}\r\n"
			}
		]
	},
	"createEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"createTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-02-18T10:06:33.291+01:00"
		}
	},
	"editEmail" : {
		"__type" : "email",
		"emailString" : "<unknown>"
	},
	"editTime" : {
		"__type" : "time",
		"time" : {
			"__type" : "dateAndTime",
			"dateAndTimeString" : "2025-02-18T10:06:33.291+01:00"
		}
	},
	"pageType" : {
		"__type" : "namedPage",
		"title" : "Parser demo"
	},
	"uid" : {
		"__type" : "uuid",
		"uuid" : "68d333b1-c8ea-0d00-9210-ed18099ea682"
	}
}